このコマンドは、Redis文字列をビットの配列として扱い、さまざまなビット幅および任意の（必要な）位置合わせされていないオフセットの特定の整数フィールドをアドレス指定できます。実際には、このコマンドを使用して、たとえばビットオフセット1234の符号付き5ビット整数を特定の値に設定し、オフセット4567から31ビットの符号なし整数を取得することができます。ユーザーが設定できる、保証され、明確に指定されたオーバーフローおよびアンダーフローの動作。

`BITFIELD`は、同じコマンド呼び出しで複数のビットフィールドを操作することができます。実行する操作のリストを受け取り、応答の配列を返します。各配列は引数のリスト内の対応する操作と一致します。

たとえば、次のコマンドはビットオフセット100で8ビット符号付き整数をインクリメントし、ビットオフセット0で4ビット符号なし整数の値を取得します。

```
> BITFIELD mykey INCRBY i5 100 1 GET u4 0
1) (integer) 1
2) (integer) 0
```

注意点:

1. 現在の文字列長の外側をアドレス指定してビットを `GET` しようとすると (キーが存在しない場合も含みます), 存在しない部分に 0 が設定されていた場合と同様の結果を返します。
2. 現在の文字列長の外側をアドレス指定していして、ビットを `SET`または `INCRBY` すると、最も遠いビットに合わせて、必要な最小長になるまで文字列が拡張され、必要に応じてゼロパディングが行われます。

## サポートされているサブコマンドと整数型

以下はサポートされているコマンドの一覧です。

- **GET** `<type>` `<offset>` - 指定されたビットフィールドを返します。
- **SET** `<type>` `<offset>` `<value>` - 指定されたビットフィールドを設定し、その古い値を返します。
- **INCRBY** `<type>` `<offset>` `<increment>` - 指定したビットフィールドを増分または減分し（負の増分が指定されている場合）、新しい値を返します。

オーバーフロー動作を設定することによって、連続した`INCRBY`サブコマンド呼び出しの動作を変更するだけのサブコマンドもあります。

- **OVERFLOW** `[WRAP|SAT|FAIL]`

整数型を指定する箇所では、符号付き整数の場合は`i`を、符号なし整数の場合は`u`を先頭につけ、そのあとに整数型のビット数を書きます。したがって、たとえば、 `u8`は8ビットの符号なし整数、 `i16`は16ビットの符号付き整数です。

サポートされている型は、符号付き整数の場合は最大64ビット、符号なし整数の場合は最大63ビットです。符号なし整数に関するこの制限は、現在Redisプロトコルが応答として64ビット符号なし整数を返すことができないという事実によるものです。

## ビットと位置オフセット

bitfieldコマンドでオフセットを指定するには2つの方法があります。接頭辞を付けずに数値を指定すると、文字列内のゼロベースのビットオフセットとして使用されます。

一方、オフセットの先頭に文字 `#` が付いている場合は、指定されたオフセットに整数型の幅が掛けられます。たとえば、次のようになります。

```
BITFIELD mystring SET i8 #0 100 i8 #1 200
```

最初のi8整数をオフセット0に設定し、2番目の整数をオフセット8に設定します。このようにして、必要なものが特定のサイズの整数の単純な配列であれば、自分で計算を行う必要はありません。

## オーバーフロー制御

`OVERFLOW`コマンドを使用して、ユーザーは以下の動作のいずれかを指定することによって、増分または減分のオーバーフロー（またはアンダーフロー）の動作を微調整できます。

- **WRAP**: 符号付き整数と符号なし整数の両方でラップアラウンドします。符号なし整数の場合、ラッピングはその整数が含むことができる最大値を法としてモジュロ演算を実行することに似ています（C標準動作）。符号なし整数の場合、オーバーフローは負の最小値から、アンダーフローは正の最大値から再スタートします。たとえば、 `i8` 型整数の値が 127 のとき, 1 インクリメントすると `-128` になります。
- **SAT**: 飽和演算を使用します。つまり、アンダーフローでは値は最小整数値に設定され、オーバーフローでは最大整数値に設定されます。たとえば、値120から始まる`i8` 型整数を10インクリメントすると、値127になり、それ以降のインクリメントでは常に値127に保たれます。アンダーフローでも同様ですが、値は負の最小値でブロックされます。
- **FAIL**: このモードでは、オーバーフローまたはアンダーフローが発生した場合、何も操作は実行されません。状況を呼び出し元に知らせるために、対応する戻り値は、NULLに設定されます。

各`OVERFLOW`ステートメントは、次の`OVERFLOW`ステートメントまで、サブコマンドのリスト内でそれに続く`INCRBY`コマンドにのみ影響することに注意してください。

特に指定がなければ、デフォルトで**WRAP**が使用されます。

```
> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 1
2) (integer) 1
> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 2
2) (integer) 2
> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 3
2) (integer) 3
> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 0
2) (integer) 3
```

## 戻り値

このコマンドは、各エントリが同じ位置に指定されたサブコマンドの対応する結果である配列を返します。 `OVERFLOW`サブコマンドは生成されたリプライには含まれません。

以下は、NULLを返す`OVERFLOW FAIL`例です。

```
> BITFIELD mykey OVERFLOW FAIL incrby u2 102 1
1) (nil)
```

## 動機

このコマンドの動機は、多数の小さい整数を1つの大きなビットマップとして格納する（または巨大なキーを使用しないようにいくつかのキーに分割する）ことはメモリ効率が非常に高く、特にRedisの新しいユースケースが適用されることです。リアルタイム分析の分野。このユースケースは、制御された方法でオーバーフローを指定する機能によってサポートされています。

楽しい事実：Redditの2017年のエイプリルフールプロジェクト[r/place](https://reddit.com/r/place)では、共有キャンバスをインメモリ表現するために[Redis BITFIELDコマンドを使用して構築](https://redditblog.com/2017/04/13/how-we-built-rplace/)されました 。

## パフォーマンスの考慮事項

通常`BITFIELD`は速いコマンドですが、現在は短い文字列に対して遠いビットアドレスを指定すると、メモリ割り当てが発生し、すでに存在するビットに対してコマンドを実行するよりもコストがかかる可能性があることに注意してください。

## ビットの順序

`BITFIELD`使用される`BITFIELD`は、ビットマップ0を最初のバイトの最上位ビットと見なし、以下同様にオフセット7の値23に5ビット符号なし整数を設定するビットマップを考慮します。すべてゼロの場合、次のようになります。

```
+--------+--------+
|00000001|01110000|
+--------+--------+
```

オフセットと整数サイズがバイト境界にアライメントされている場合、これはビッグエンディアンと同じですが、そのようなアライメントが存在しない場合は、バイト内のビットがどのように並んでいるかを理解することも重要です。
