文字列内の1または0に設定された最初のビットの位置を返します。

最初のバイトの最上位ビットが位置0にあり、2番目のバイトの最上位ビットが位置8にあるというように、文字列を左から右へのビットの配列と見なして、位置が返されます。

`GETBIT` と `SETBIT` のビット位置の規則は同じです。

デフォルトでは、文字列に含まれるすべてのバイトが調べられます。引数に*start*と*end*を指定することで、特定の区間のビット列のみを調べることができます。（*start*のみを渡すことも可能です。その場合 end には文字列の最後のバイトが指定されたものとみなします。しかし後で説明するような解釈の違いがあります）。範囲はビットの範囲ではなくバイトの範囲として解釈されるため、 `start=0` および `end=2`は最初の3バイトを調べることを意味します。

範囲を指定するために*start*と*end*が使用されている場合でも、ビット位置は常にビット0から始まる絶対値として返されることに注意してください。

`GETRANGE`コマンドの場合と同様に、文字列の末尾から始まるバイトにインデックスを付けるために、startとendに負の値を含めることができます。ここで、-1は最後のバイト、-2は最後から2番目です。

存在しないキーは空の文字列として扱われます。

@return

@integer-reply

コマンドは、要求に従って1または0に設定された最初のビットの位置を返します。

セットビット (bit引数が1) を検索していて、文字列が空であるかゼロのバイトだけで構成されている場合、-1が返されます。

クリアビット (bit引数が0) を検索し、文字列に1に設定されたビットしか含まれていない場合、この関数は右側の文字列のセットされていない最初のビットを返します。そのため、`0xff`設定された3バイトの文字列の場合、コマンド`BITPOS key 0`は24を返します。23ビット目まではすべてのビットが1であるためです。

範囲を指定しない、もしくは *start* 引数**のみ**を指定して、クリアビットを検索した場合、基本的に文字列の右側はゼロで埋められていると見なします。

ただし、 **start**と**end**の両方を範囲指定しクリアビットを検索した場合、この挙動は変わります。指定された範囲内にクリアビットが見つからない場合 -1 を返します。ユーザーが明確に範囲を指定し、その範囲に0のビットはないからです。

@example

```cli
SET mykey "\xff\xf0\x00"
BITPOS mykey 0
SET mykey "\x00\xff\xf0"
BITPOS mykey 1 0
BITPOS mykey 1 2
set mykey "\x00\x00\x00"
BITPOS mykey 1
```
