文字列内の立っているビット数（population count）を数えます。

デフォルトでは、文字列に含まれるすべてのバイトが調べられます。追加の引数*start*と*end*を渡す間隔内でのみカウント操作を指定することができます。

`GETRANGE`コマンドの場合と同様に、文字列の末尾から始まるバイトにインデックスを付けるために、startとendに負の値を含めることができます。ここで、-1は最後のバイト、-2は最後から2番目です。

存在しないキーは空の文字列として扱われるため、コマンドはゼロを返します。

@return

@integer-reply

1に設定されたビット数。

@examples

```cli
SET mykey "foobar"
BITCOUNT mykey
BITCOUNT mykey 0 0
BITCOUNT mykey 1 1
```

## パターン：ビットマップを使用したリアルタイムメトリクス

ビットマップは、特定の種類の情報を非常にスペース効率よく表現したものです。 1つの例は、ユーザー訪問の履歴を必要とするWebアプリケーションです。そのため、たとえば、どのユーザーがベータ機能の優れたターゲットであるかを判断することができます。

`SETBIT`コマンドを使用すると、これを達成するのは簡単です。毎日、小さい累進整数で識別します。たとえば、0日目はアプリケーションがオンラインになった最初の日、1日目は翌日というように続きます。

ユーザーがページビューを実行するたびに、アプリケーションは、当日にユーザーがWebサイトを訪問したことを、当日に対応するビットを設定する`SETBIT`コマンドを使用して登録できます。

後でビットマップに対して`BITCOUNT`コマンドを呼び出すだけで、ユーザーがWebサイトにアクセスした1日の数を知ることは簡単です。

日数の代わりにユーザーIDが使用される同様のパターンは、 "[Redisビットマップを使用した高速で簡単なリアルタイムメトリクス](http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps) "という記事で説明されています 。

## パフォーマンスの考慮事項

上記の日数計算の例では、10年経ってもアプリケーションがオンラインの場合でも、1ユーザーあたり`365*10`ビットのデータ、つまり1ユーザーあたりわずか456バイトしかありません。このデータ量では、 `BITCOUNT`や`GET`や`INCR` ような他の O(1) Redisコマンドと同じくらい速いです。

ビットマップが大きい場合、2つの選択肢があります。

- ビットマップが変更されるたびにインクリメントされる分離キーを取得します。これは、小さなRedis Luaスクリプトを使うことで非常に効率的かつアトミックになります。
- `BITCOUNT` *開始*および*終了*オプションパラメータを使用してビットマップを増分的に実行し、結果をクライアント側で累積し、必要に応じて結果をキーにキャッシュします。
